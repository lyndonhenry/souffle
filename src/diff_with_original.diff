diff --git a/kafka/tmp/edenhill/librdkafka b/kafka/tmp/edenhill/librdkafka
new file mode 160000
index 00000000..aa63660a
--- /dev/null
+++ b/kafka/tmp/edenhill/librdkafka
@@ -0,0 +1 @@
+Subproject commit aa63660a090ccf002b591d9a91d9a0f47449d043-dirty
diff --git a/src/A.facts b/src/A.facts
new file mode 100644
index 00000000..56d6d075
--- /dev/null
+++ b/src/A.facts
@@ -0,0 +1,2 @@
+3	4
+4	5
diff --git a/src/AstTranslator.cpp b/src/AstTranslator.cpp
index 6b4c50f9..77be1c5b 100644
--- a/src/AstTranslator.cpp
+++ b/src/AstTranslator.cpp
@@ -1027,28 +1027,43 @@ void AstTranslator::nameUnnamedVariables(AstClause* clause) {
 
 /** generate RAM code for recursive relations in a strongly-connected component */
 std::unique_ptr<RamStatement> AstTranslator::translateRecursiveRelation(
-        const std::set<const AstRelation*>& scc, const RecursiveClauses* recursiveClauses) {
+        const std::set<const AstRelation*>& relations, const RecursiveClauses* recursiveClauses,
+         const AstTranslationUnit& translationUnit, std::size_t indexOfScc) {
     // initialize sections
-    std::unique_ptr<RamStatement> preamble;
+    std::unique_ptr<RamStatement> preamble(new RamSequence());
     std::unique_ptr<RamSequence> updateTable(new RamSequence());
     std::unique_ptr<RamStatement> postamble;
 
     // --- create preamble ---
+    const auto& sccGraph = *translationUnit.getAnalysis<SCCGraph>();
+    const auto externalPreds = sccGraph.getExternalPredecessorRelations(indexOfScc);
+#if 0
+    // @TODO (lh): add merge statements for all external predecessor relations within the loop, need to merge and swap news (into current?)
+    // @TODO (lh): add merge statements for all external predecessor relations before the loop, need to merge current into delt
+    // TODO: add merge for all external predecessors of scc 
+        /* create update statements for fixpoint (even iteration) */
+
+#endif 
+
+    for(const AstRelation *rel :  externalPreds)  {
+
+        /* Generate merge operation for temp tables */
+        appendStmt(preamble,
+                std::make_unique<RamMerge>(
+                    std::unique_ptr<RamRelationReference>(relDelta[rel]->clone()),
+                        std::unique_ptr<RamRelationReference>(rrel[rel]->clone())
+                        ));
 
-    // mappings for temporary relations
-    std::map<const AstRelation*, std::unique_ptr<RamRelationReference>> rrel;
-    std::map<const AstRelation*, std::unique_ptr<RamRelationReference>> relDelta;
-    std::map<const AstRelation*, std::unique_ptr<RamRelationReference>> relNew;
+    } 
 
     /* Compute non-recursive clauses for relations in scc and push
        the results in their delta tables. */
-    for (const AstRelation* rel : scc) {
+    for (const AstRelation* rel : relations) {
+
+        std::cout << *rel << std::endl;
+
         std::unique_ptr<RamStatement> updateRelTable;
 
-        /* create two temporary tables for relaxed semi-naive evaluation */
-        rrel[rel] = translateRelation(rel);
-        relDelta[rel] = translateDeltaRelation(rel);
-        relNew[rel] = translateNewRelation(rel);
 
         /* create update statements for fixpoint (even iteration) */
         appendStmt(updateRelTable,
@@ -1075,51 +1090,104 @@ std::unique_ptr<RamStatement> AstTranslator::translateRecursiveRelation(
                                       std::make_unique<RamClear>(
                                               std::unique_ptr<RamRelationReference>(relNew[rel]->clone()))));
 
+#if 0
         /* Generate code for non-recursive part of relation */
         appendStmt(preamble, translateNonRecursiveRelation(*rel, recursiveClauses));
+#endif
 
+#if 0
         /* Generate merge operation for temp tables */
         appendStmt(preamble,
                 std::make_unique<RamMerge>(std::unique_ptr<RamRelationReference>(relDelta[rel]->clone()),
                         std::unique_ptr<RamRelationReference>(rrel[rel]->clone())));
 
+#endif 
+
+
         /* Add update operations of relations to parallel statements */
         updateTable->add(std::move(updateRelTable));
     }
 
+    for(const AstRelation *rel :  externalPreds)  {
+
+        std::unique_ptr<RamStatement> updateRelTable;
+
+        /* Generate merge operation for temp tables */
+        appendStmt(updateRelTable,
+                std::make_unique<RamSequence>(
+                        std::make_unique<RamMerge>(std::unique_ptr<RamRelationReference>(rrel[rel]->clone()),
+                                std::unique_ptr<RamRelationReference>(relNew[rel]->clone())),
+                        std::make_unique<RamSwap>(
+                                std::unique_ptr<RamRelationReference>(relDelta[rel]->clone()),
+                                std::unique_ptr<RamRelationReference>(relNew[rel]->clone())),
+                        std::make_unique<RamClear>(
+                                std::unique_ptr<RamRelationReference>(relNew[rel]->clone()))));
+
+        /* Add update operations of relations to parallel statements */
+        updateTable->add(std::move(updateRelTable));
+
+
+    } 
+
     // --- build main loop ---
 
     std::unique_ptr<RamParallel> loopSeq(new RamParallel());
 
     // create a utility to check SCC membership
     auto isInSameSCC = [&](const AstRelation* rel) {
-        return std::find(scc.begin(), scc.end(), rel) != scc.end();
+        return std::find(relations.begin(), relations.end(), rel) != relations.end();
     };
 
     /* Compute temp for the current tables */
-    for (const AstRelation* rel : scc) {
+    for (const AstRelation* rel : relations) {
         std::unique_ptr<RamStatement> loopRelSeq;
 
         /* Find clauses for relation rel */
         for (size_t i = 0; i < rel->clauseSize(); i++) {
             AstClause* cl = rel->getClause(i);
+             std::cout << "\t" <<  *cl << std::endl;
 
+#if 0
             // skip non-recursive clauses
             if (!recursiveClauses->recursive(cl)) {
                 continue;
             }
+#endif 
 
             // each recursive rule results in several operations
             int version = 0;
             const auto& atoms = cl->getAtoms();
+
+            std::cout << "\t\t" << atoms.size() << std::endl; 
+            if (atoms.size() == 0) { 
+                // modify the processed rule to use relDelta and write to relNew
+                std::unique_ptr<AstClause> r1(cl->clone());
+                r1->getHead()->setName(relNew[rel]->get()->getName());
+
+                if (r1->getHead()->getArity() > 0)
+                    r1->addToBody(std::make_unique<AstNegation>(
+                        std::unique_ptr<AstAtom>(cl->getHead()->clone())));
+
+                std::unique_ptr<RamStatement> rule =
+                        ClauseTranslator(*this).translateClause(*r1, *cl, version);
+
+                // add to loop body
+                appendStmt(loopRelSeq, std::move(rule));
+
+                // TODO: handle logging 
+
+            } 
             for (size_t j = 0; j < atoms.size(); ++j) {
                 const AstAtom* atom = atoms[j];
                 const AstRelation* atomRelation = getAtomRelation(atom, program);
 
+
+#if 0
                 // only interested in atoms within the same SCC
                 if (!isInSameSCC(atomRelation)) {
                     continue;
                 }
+#endif 
 
                 // modify the processed rule to use relDelta and write to relNew
                 std::unique_ptr<AstClause> r1(cl->clone());
@@ -1140,11 +1208,15 @@ std::unique_ptr<RamStatement> AstTranslator::translateRecursiveRelation(
 
                 // reduce R to P ...
                 for (size_t k = j + 1; k < atoms.size(); k++) {
+#if 0
                     if (isInSameSCC(getAtomRelation(atoms[k], program))) {
+#endif 
                         AstAtom* cur = r1->getAtoms()[k]->clone();
                         cur->setName(relDelta[getAtomRelation(atoms[k], program)]->get()->getName());
                         r1->addToBody(std::make_unique<AstNegation>(std::unique_ptr<AstAtom>(cur)));
+#if 0
                     }
+#endif 
                 }
 
                 std::unique_ptr<RamStatement> rule =
@@ -1205,7 +1277,7 @@ std::unique_ptr<RamStatement> AstTranslator::translateRecursiveRelation(
     };
 
     std::unique_ptr<RamCondition> exitCond;
-    for (const AstRelation* rel : scc) {
+    for (const AstRelation* rel : relations) {
         addCondition(exitCond, std::make_unique<RamEmptinessCheck>(
                                        std::unique_ptr<RamRelationReference>(relNew[rel]->clone())));
     }
@@ -1492,6 +1564,9 @@ void AstTranslator::translateProgram(const AstTranslationUnit& translationUnit)
     // obtain the schedule of relations expired at each index of the topological order
     const auto& expirySchedule = translationUnit.getAnalysis<RelationSchedule>()->schedule();
 
+    // program 
+    const auto& program = translationUnit.getProgram();
+
     // start with an empty sequence of ram statements
     std::unique_ptr<RamStatement> res = std::make_unique<RamSequence>();
 
@@ -1536,6 +1611,13 @@ void AstTranslator::translateProgram(const AstTranslationUnit& translationUnit)
     // maintain the index of the SCC within the topological order
     size_t indexOfScc = 0;
 
+    for (auto rel : program->getRelations()) {
+        /* create two temporary tables for relaxed semi-naive evaluation */
+        rrel[rel] = translateRelation(rel);
+        relDelta[rel] = translateDeltaRelation(rel);
+        relNew[rel] = translateNewRelation(rel);
+    } 
+
     // iterate over each SCC according to the topological order
     for (const auto& scc : sccOrder.order()) {
         // make a new ram statement for the current SCC
@@ -1580,11 +1662,16 @@ void AstTranslator::translateProgram(const AstTranslationUnit& translationUnit)
                 }
             }
         }
+
+#if 0
         // compute the relations themselves
         std::unique_ptr<RamStatement> bodyStatement =
                 (!isRecursive) ? translateNonRecursiveRelation(
                                          *((const AstRelation*)*allInterns.begin()), recursiveClauses)
                                : translateRecursiveRelation(allInterns, recursiveClauses);
+#else                               
+        std::unique_ptr<RamStatement> bodyStatement = translateRecursiveRelation(allInterns, recursiveClauses, translationUnit, indexOfScc);
+#endif 
         appendStmt(current, std::move(bodyStatement));
         {
             // if a communication engine is enabled...
diff --git a/src/AstTranslator.h b/src/AstTranslator.h
index 3db42a90..e3c0eb5f 100644
--- a/src/AstTranslator.h
+++ b/src/AstTranslator.h
@@ -18,6 +18,7 @@
 
 #include "AstArgument.h"
 #include "AstRelationIdentifier.h"
+#include "PrecedenceGraph.h"
 #include "RamRelation.h"
 #include "RelationRepresentation.h"
 #include "Util.h"
@@ -384,7 +385,7 @@ private:
 
     /** translate RAM code for recursive relations in a strongly-connected component */
     std::unique_ptr<RamStatement> translateRecursiveRelation(
-            const std::set<const AstRelation*>& scc, const RecursiveClauses* recursiveClauses);
+            const std::set<const AstRelation*>& relations, const RecursiveClauses* recursiveClauses, const AstTranslationUnit& translationUnit, const std::size_t scc);
 
     /** translate RAM code for subroutine to get subproofs */
     std::unique_ptr<RamStatement> makeSubproofSubroutine(const AstClause& clause);
@@ -397,6 +398,11 @@ private:
 
     /** translate AST to RAM Program */
     void translateProgram(const AstTranslationUnit& translationUnit);
+
+    // mappings for temporary relations
+    std::map<const AstRelation*, std::unique_ptr<RamRelationReference>> rrel;
+    std::map<const AstRelation*, std::unique_ptr<RamRelationReference>> relDelta;
+    std::map<const AstRelation*, std::unique_ptr<RamRelationReference>> relNew;
 };
 
 }  // end of namespace souffle
diff --git a/src/B.csv b/src/B.csv
new file mode 100644
index 00000000..b92092d8
--- /dev/null
+++ b/src/B.csv
@@ -0,0 +1,4 @@
+1	2
+2	3
+3	4
+4	5
diff --git a/src/main.cpp b/src/main.cpp
index f06e07af..6de436c8 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -188,7 +188,7 @@ int main(int argc, char** argv) {
                 {"verbose", 'v', "", "", false, "Verbose output."},
                 {"version", '\3', "", "", false, "Version."},
                 {"transformed-datalog", '\4', "", "", false, "Output dl after all transformations."},
-                {"transformed-ram", '\6', "", "", false, "Output ram program after all transformations."},
+                {"transformed-ram", 'R', "", "", false, "Output ram program after all transformations."},
                 {"parse-errors", '\5', "", "", false, "Show parsing errors, if any, then exit."},
                 {"help", 'h', "", "", false, "Display this help message."}};
         Global::config().processArgs(argc, argv, header.str(), footer.str(), options);
diff --git a/src/test.dl b/src/test.dl
new file mode 100644
index 00000000..94e3b653
--- /dev/null
+++ b/src/test.dl
@@ -0,0 +1,10 @@
+.decl A(x:number, y:number)
+.decl B(x:number, y:number)
+.input A()
+.output B()
+
+A(1, 2).
+A(2, 3).
+
+B(x, y) :- A(x, y).
+B(x, y) :- A(x, y), B(x, y).
